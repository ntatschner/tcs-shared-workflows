# Creates and pushes a version tag (e.g. v0.0.3) when the module manifest version
# is greater than the current latest tag. Use on push to main after bumping ModuleVersion.
name: Create Version Tag

on:
  workflow_call:
    inputs:
      module-name:
        description: 'Name of the PowerShell module (used for logging).'
        required: true
        type: string
      module-path:
        description: 'Relative path to the module directory containing the manifest.'
        required: true
        type: string
      module-manifest:
        description: 'Optional path to the .psd1. Defaults to <module-path>/<module-name>.psd1.'
        required: false
        type: string
      tag-prefix:
        description: 'Prefix for the tag (e.g. v for v0.0.3).'
        required: false
        type: string
        default: 'v'
      ref:
        description: 'Optional ref (commit SHA, branch, or tag) to checkout. Use workflow_run.head_sha when chained after CI Validate.'
        required: false
        type: string
    secrets:
      repo-token:
        description: 'Token with contents: write (to push tags). Defaults to GITHUB_TOKEN.'
        required: false

jobs:
  create-tag:
    name: Create tag if version increased
    runs-on: windows-latest
    permissions:
      contents: write
    env:
      MODULE_NAME: ${{ inputs.module-name }}
      MODULE_PATH: ${{ inputs.module-path }}
      MODULE_MANIFEST: ${{ inputs.module-manifest != '' && inputs.module-manifest || format('{0}/{1}.psd1', inputs.module-path, inputs.module-name) }}
      TAG_PREFIX: ${{ inputs.tag-prefix }}
      REPO_TOKEN: ${{ secrets.repo-token != '' && secrets.repo-token || github.token }}
    outputs:
      tag_created: ${{ steps.tag.outputs.tag_created }}
      new_tag: ${{ steps.tag.outputs.new_tag }}
    steps:
      - name: Checkout (fetch all tags)
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref || github.ref }}
          fetch-depth: 0
          token: ${{ env.REPO_TOKEN }}

      - name: Fetch tags from origin
        shell: bash
        run: git fetch origin --tags --force
        env:
          GITHUB_TOKEN: ${{ env.REPO_TOKEN }}

      - name: Get manifest version and latest tag, create tag if increased
        id: tag
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          if (-not (Test-Path $env:MODULE_MANIFEST)) {
            throw "Module manifest not found: $env:MODULE_MANIFEST"
          }
          $manifest = Import-PowerShellDataFile -Path $env:MODULE_MANIFEST
          $manifestVersion = $manifest.ModuleVersion
          if (-not $manifestVersion) {
            throw "ModuleVersion not found in $env:MODULE_MANIFEST"
          }
          $manifestVer = [version]$manifestVersion
          Write-Host "Manifest version: $manifestVersion" -ForegroundColor Cyan

          $prefix = $env:TAG_PREFIX.Trim()
          $newTag = "${prefix}${manifestVersion}"

          # Check remote first: if this tag already exists on origin, skip (no local state dependency)
          $remoteRef = git ls-remote origin "refs/tags/$newTag" 2>$null
          if ($remoteRef) {
            Write-Host "Tag $newTag already exists on remote. Skipping." -ForegroundColor Yellow
            "tag_created=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
            "new_tag=$newTag" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
            exit 0
          }

          # List remote tags with prefix (git ls-remote outputs "SHA\tref" per line)
          $remoteTagsRaw = git ls-remote --refs origin "refs/tags/${prefix}*" 2>$null
          $tagNames = @($remoteTagsRaw) | ForEach-Object {
            $ref = ($_ -split "`t", 2)[1]
            if ($ref -and $ref -match '^refs/tags/(.+)$') { $matches[1] }
          } | Where-Object { $_ }
          $latestVersion = $null
          $latestTag = $null
          foreach ($t in $tagNames) {
            $tagOnly = $t -replace "^$([regex]::Escape($prefix))", ''
            $tryVer = $null
            if ([version]::TryParse($tagOnly, [ref]$tryVer)) {
              if (-not $latestVersion -or $tryVer -gt $latestVersion) {
                $latestVersion = $tryVer
                $latestTag = $t
              }
            }
          }
          if ($latestTag) {
            Write-Host "Latest tag on remote: $latestTag (version $($latestVersion.ToString()))" -ForegroundColor Cyan
          }
          else {
            Write-Host "No previous version tag found on remote. Creating first tag." -ForegroundColor Yellow
          }

          if ($latestVersion -and $manifestVer -le $latestVersion) {
            Write-Host "Manifest version $manifestVersion is not greater than latest tag ($latestTag). No tag created." -ForegroundColor Yellow
            "tag_created=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
            "new_tag=" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
            exit 0
          }

          git tag $newTag
          if ($LASTEXITCODE -ne 0) { throw "git tag failed (exit code $LASTEXITCODE)" }
          git push origin $newTag
          if ($LASTEXITCODE -ne 0) {
            # Check if tag was created by a concurrent run
            $recheck = git ls-remote origin "refs/tags/$newTag" 2>$null
            if ($recheck) {
              Write-Host "Tag $newTag was created by a concurrent run. Skipping." -ForegroundColor Yellow
              "tag_created=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
              "new_tag=$newTag" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
              exit 0
            }
            throw "Failed to push tag $newTag (exit code $LASTEXITCODE). Check repo permissions."
          }
          Write-Host "Created and pushed tag: $newTag" -ForegroundColor Green
          "tag_created=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "new_tag=$newTag" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
