name: PowerShell Documentation Generation

on:
  workflow_call:
    inputs:
      module-name:
        description: 'Name of the PowerShell module to load when generating documentation.'
        required: true
        type: string
      module-path:
        description: 'Relative path to the module directory that contains the manifest and source files.'
        required: true
        type: string
      module-manifest:
        description: 'Optional explicit path to the module manifest (.psd1). Defaults to <module-path>/<module-name>.psd1 when omitted.'
        required: false
        type: string
      docs-path:
        description: 'Relative path where the markdown documentation should be written.'
        required: false
        type: string
        default: './docs'
      locale:
        description: 'Locale folder name to use when generating external help.'
        required: false
        type: string
        default: 'en-GB'
      required-modules:
        description: 'Optional newline-separated list of modules to install before generating documentation.'
        required: false
        type: string
      pre-import-script-path:
        description: 'Optional path to a PowerShell script to execute prior to importing the target module (for custom stubs or setup).'
        required: false
        type: string
      commit-docs:
        description: 'Set to false to skip committing documentation updates.'
        required: false
        type: boolean
        default: true
      git-user-name:
        description: 'Optional Git username to use when committing documentation updates.'
        required: false
        type: string
      git-user-email:
        description: 'Optional Git email to use when committing documentation updates.'
        required: false
        type: string
      commit-message:
        description: 'Commit message to use when documentation changes are detected.'
        required: false
        type: string
        default: 'docs: auto-generated PowerShell help [skip ci]'
      ref:
        description: 'Optional ref (commit SHA, branch, or tag) to checkout. Use workflow_run.head_sha when chained after CI Validate.'
        required: false
        type: string
    secrets:
      repo-token:
        description: 'Optional token with contents: write permissions. Defaults to the calling workflow GITHUB_TOKEN when omitted.'
        required: false

jobs:
  generate-docs:
    name: Generate PowerShell Documentation
    runs-on: windows-latest
    permissions:
      contents: write
      pull-requests: write
    env:
      MODULE_NAME: ${{ inputs.module-name }}
      MODULE_PATH: ${{ inputs.module-path }}
      MODULE_MANIFEST: ${{ inputs.module-manifest != '' && inputs.module-manifest || format('{0}/{1}.psd1', inputs.module-path, inputs.module-name) }}
      DOCS_PATH: ${{ inputs.docs-path }}
      DOCS_LOCALE: ${{ inputs.locale }}
      COMMIT_MESSAGE: ${{ inputs.commit-message }}
      COMMIT_ENABLED: ${{ inputs.commit-docs }}
      REQUIRED_MODULES: ${{ inputs.required-modules }}
      PRE_IMPORT_SCRIPT: ${{ inputs.pre-import-script-path }}
      GIT_USER_NAME: ${{ inputs.git-user-name }}
      GIT_USER_EMAIL: ${{ inputs.git-user-email }}
      REPO_TOKEN: ${{ secrets.repo-token != '' && secrets.repo-token || github.token }}
    outputs:
      docs-updated: ${{ steps.commit-docs.outputs.docs_updated }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref || github.ref }}
          fetch-depth: 0
          token: ${{ env.REPO_TOKEN }}

      - name: Prepare git and rebase when on a branch
        shell: pwsh
        env:
          GIT_USER_NAME: ${{ env.GIT_USER_NAME != '' && env.GIT_USER_NAME || 'github-actions[bot]' }}
          GIT_USER_EMAIL: ${{ env.GIT_USER_EMAIL != '' && env.GIT_USER_EMAIL || 'github-actions[bot]@users.noreply.github.com' }}
        run: |
          git config user.name "$env:GIT_USER_NAME"
          git config user.email "$env:GIT_USER_EMAIL"
          git config core.autocrlf false
          # Reset working tree so rebase does not see checkout-induced changes (e.g. line endings on Windows)
          git reset --hard HEAD
          $branch = git symbolic-ref -q --short HEAD
          # Reset LASTEXITCODE so detached-HEAD (exit 1 from symbolic-ref -q) does not propagate to pwsh exit code
          $global:LASTEXITCODE = 0
          if ($branch) {
            git fetch origin $branch
            if ($LASTEXITCODE -ne 0) { throw "git fetch failed (exit code $LASTEXITCODE)" }
            git rebase "origin/$branch"
            if ($LASTEXITCODE -ne 0) {
              git rebase --abort 2>$null
              throw "git rebase failed (exit code $LASTEXITCODE) -- possible conflict with concurrent push"
            }
          }

      - name: Cache PowerShell Modules
        id: cache-modules
        uses: actions/cache@v4
        with:
          path: |
            ~\Documents\PowerShell\Modules
            C:\Users\runneradmin\Documents\PowerShell\Modules
          key: ${{ runner.os }}-pwsh-modules-${{ hashFiles(inputs.module-manifest != '' && inputs.module-manifest || format('{0}/{1}.psd1', inputs.module-path, inputs.module-name)) }}
          restore-keys: |
            ${{ runner.os }}-pwsh-modules-

      - name: Install PlatyPS
        if: steps.cache-modules.outputs.cache-hit != 'true'
        shell: pwsh
        run: |
          Install-Module -Name PlatyPS -Force -Scope CurrentUser -AllowClobber

      - name: Install Required Modules
        if: inputs.required-modules != ''
        shell: pwsh
        env:
          REQUIRED_MODULES: ${{ env.REQUIRED_MODULES }}
        run: |
          $modules = $env:REQUIRED_MODULES -split "`n" | ForEach-Object { $_.Trim() } | Where-Object { $_ }
          foreach ($moduleName in $modules) {
            Write-Host "Installing required module: $moduleName" -ForegroundColor Cyan
            Install-Module -Name $moduleName -Force -Scope CurrentUser -AllowClobber
          }

      - name: Run Pre-Import Script
        if: inputs.pre-import-script-path != ''
        shell: pwsh
        env:
          SCRIPT_PATH: ${{ inputs.pre-import-script-path }}
        run: |
          $resolvedPath = Join-Path (Get-Location) $env:SCRIPT_PATH
          if (-not (Test-Path $resolvedPath)) {
            throw "Pre-import script not found at path: $resolvedPath"
          }

          Write-Host "Executing pre-import script at '$resolvedPath'..." -ForegroundColor Green
          . $resolvedPath

      - name: Resolve RequiredModules
        uses: ntatschner/tcs-shared-workflows/.github/actions/resolve-required-modules@main
        with:
          module-manifest: ${{ env.MODULE_MANIFEST }}

      - name: Import Module Dependencies
        shell: pwsh
        env:
          MODULE_MANIFEST: ${{ env.MODULE_MANIFEST }}
          MODULE_NAME: ${{ env.MODULE_NAME }}
        run: |
          Import-Module PlatyPS -Force
          $resolvedManifestPath = Resolve-Path -Path $env:MODULE_MANIFEST -ErrorAction Stop

          Import-Module -Name $resolvedManifestPath -Force -Verbose

          $module = Get-Module $env:MODULE_NAME
          if (-not $module) {
            throw "Module '$env:MODULE_NAME' failed to load."
          }

          Write-Host "Loaded module $($module.Name) version $($module.Version)." -ForegroundColor Green
          Write-Host "Exported functions: $($module.ExportedFunctions.Keys -join ', ')" -ForegroundColor Cyan

      - name: Generate Markdown Documentation
        shell: pwsh
        env:
          MODULE_MANIFEST: ${{ env.MODULE_MANIFEST }}
          MODULE_NAME: ${{ env.MODULE_NAME }}
          DOCS_PATH: ${{ env.DOCS_PATH }}
        run: |
          $ErrorActionPreference = 'Stop'
          Import-Module PlatyPS -Force
          $resolvedManifestPath = Resolve-Path -Path $env:MODULE_MANIFEST -ErrorAction Stop
          Import-Module -Name $resolvedManifestPath -Force

          if (-not (Test-Path $env:DOCS_PATH)) {
            New-Item -Path $env:DOCS_PATH -ItemType Directory -Force | Out-Null
          }

          Write-Host 'Generating markdown help...' -ForegroundColor Green
          New-MarkdownHelp -Module $env:MODULE_NAME -OutputFolder $env:DOCS_PATH -Force
          $aboutPath = Join-Path $env:DOCS_PATH "about_$env:MODULE_NAME.md"
          if (Test-Path $aboutPath) { Remove-Item $aboutPath -Force }
          New-MarkdownAboutHelp -OutputFolder $env:DOCS_PATH -AboutName $env:MODULE_NAME


      - name: Update Existing Markdown
        shell: pwsh
        env:
          DOCS_PATH: ${{ env.DOCS_PATH }}
          MODULE_MANIFEST: ${{ env.MODULE_MANIFEST }}
        run: |
          Import-Module PlatyPS -Force

          try {
            $resolvedManifestPath = Resolve-Path -Path $env:MODULE_MANIFEST -ErrorAction Stop
            Import-Module -Name $resolvedManifestPath -Force -ErrorAction Stop
          } catch {
            Write-Host "::error::Module import failed: $_"
            throw
          }

          function Normalize-MarkdownHeaders {
            param([string]$DocsPath)
            if (-not (Test-Path $DocsPath)) {
              Write-Host 'Docs path not present, skipping normalization.' -ForegroundColor Yellow
              return
            }

            Write-Host 'Normalizing markdown header patterns in generated docs...' -ForegroundColor Green
            $patterns = @('Description','Synopsis','Parameters','Notes','Examples','Returns','Input','Output')
            Get-ChildItem -Path $DocsPath -Recurse -Filter *.md -ErrorAction SilentlyContinue |
              ForEach-Object {
                $path = $_.FullName
                try {
                  $text = Get-Content -Raw -Encoding UTF8 -ErrorAction Stop $path
                } catch {
                  Write-Warning ("Could not read {0}: {1}" -f $path, $_)
                  return
                }
                $orig = $text
                # Fix cases where the opening ```yaml fence and the first YAML line were rendered on the same line
                # e.g. ```yaml Type: String[]
                $text = [regex]::Replace($text, '(?m)^```yaml[ \t]+(.+)$', { param($m) '```yaml' + [Environment]::NewLine + $m.Groups[1].Value })

                # Split multiple 'Key: Value' pairs that ended up on the same line inside YAML blocks
                $pattern = '(?ms)```yaml\s*(.+?)\s*```'
                $yamlBlocks = [regex]::Matches($text, $pattern)
                if ($yamlBlocks.Count -gt 0) {
                  $offset = 0
                  foreach ($m in $yamlBlocks) {
                    $inner = $m.Groups[1].Value
                    # More aggressive splitting: split on any pattern that looks like 'Key:'
                    # This handles cases like 'Type: String[] Parameter Sets: (All)' or 'Required: True Aliases: none'
                    $lines = @()
                    $currentLine = ''
                    $tokens = $inner -split '(\s+(?=[A-Z][a-zA-Z\s]+:))'
                    foreach ($token in $tokens) {
                      if ($token -match '^\s+$') { continue }
                      if ($currentLine -and $token -match '^[A-Z][a-zA-Z\s]+:') {
                        $lines += $currentLine.TrimEnd()
                        $currentLine = $token.TrimStart()
                      } else {
                        $currentLine += $token
                      }
                    }
                    if ($currentLine) { $lines += $currentLine.TrimEnd() }
                    
                    if ($lines.Count -gt 0) {
                      $newInner = $lines -join [Environment]::NewLine
                    } else {
                      # Fallback to original regex
                      $newInner = [regex]::Replace($inner, '(:\s*[^:\r\n]+?)\s{2,}(?=[A-Z][a-zA-Z\s]+:)', '$1' + [Environment]::NewLine)
                    }
                    # Fix YAML keys so Update-MarkdownHelpModule and New-ExternalHelp accept the block (unknown key "Sets" -> "Parameter Sets", strip trailing "Parameter" from Type, "value" -> "Default value")
                    # Pre-compute all replacement strings in variables so concatenation with commas never breaks -replace
                    $nl = [Environment]::NewLine
                    $replNewlineParamSets = "`$1" + $nl + 'Parameter Sets: '
                    $replDefNone = 'Default value: None' + $nl + 'Accept pipeline input: False'
                    $replDefFalse = 'Default value: False' + $nl + 'Accept pipeline input: False'
                    $replValueToDefault = 'Default value: $1' + $nl + 'Accept pipeline input: False'
                    $newInner = $newInner -replace 'Parameter\r?\nSets: ', 'Parameter Sets: '
                    $newInner = $newInner -replace '(?m)^Sets:\s*', 'Parameter Sets: '
                    $newInner = $newInner -replace '(?m)^(Type:\s*.+?)Parameter\s*$', '$1'
                    $newInner = $newInner -replace '([^\r\n])Parameter Sets:', $replNewlineParamSets
                    $newInner = $newInner -replace 'value:NoneAcceptpipeline', $replDefNone
                    $newInner = $newInner -replace 'value: NoneAcceptpipeline', $replDefNone
                    $newInner = $newInner -replace 'value:FalseAcceptpipeline', $replDefFalse
                    $newInner = $newInner -replace 'value: FalseAcceptpipeline', $replDefFalse
                    $newInner = $newInner -replace '(?m)^value:\s*(.+?)Acceptpipeline\s*$', $replValueToDefault
                    $newInner = $newInner -replace '(?m)^value:\s*(.+)\s*$', 'Default value: $1'
                    $newBlock = '```yaml' + [Environment]::NewLine + $newInner + [Environment]::NewLine + '```'
                    $startIndex = $m.Index + $offset
                    $length = $m.Length
                    $text = $text.Substring(0, $startIndex) + $newBlock + $text.Substring($startIndex + $length)
                    $offset += ($newBlock.Length - $length)
                  }
                }
                foreach ($label in $patterns) {
                  # Build the regex by concatenation to avoid PowerShell parsing issues with (?m) and variable interpolation
                  $regex = '(?m)^\s*' + [regex]::Escape($label) + ':\s*-{3,}\s*$'
                  if ($text -match $regex) {
                    $replacementLine = [Environment]::NewLine + ('### ' + $label.ToUpper()) + [Environment]::NewLine
                    $text = [regex]::Replace($text, $regex, $replacementLine)
                  }
                }
                if ($text -ne $orig) {
                  Set-Content -Path $path -Value $text -Encoding UTF8 -NoNewline
                  Write-Host "Patched: $path" -ForegroundColor Green
                }
              }
          }

          Normalize-MarkdownHeaders -DocsPath $env:DOCS_PATH

          if (Test-Path $env:DOCS_PATH) {
            Write-Host 'Updating existing markdown help files...' -ForegroundColor Green
            try {
              Update-MarkdownHelpModule -Path $env:DOCS_PATH -RefreshModulePage -ErrorAction Stop
            } catch {
              Write-Host "::warning::Update-MarkdownHelpModule failed: $_"
            }
          }

          Normalize-MarkdownHeaders -DocsPath $env:DOCS_PATH


      - name: Generate External Help
        shell: pwsh
        env:
          DOCS_PATH: ${{ env.DOCS_PATH }}
          MODULE_PATH: ${{ env.MODULE_PATH }}
          DOCS_LOCALE: ${{ env.DOCS_LOCALE }}
        run: |
          $ErrorActionPreference = 'Stop'
          Import-Module PlatyPS -Force

          # Final normalization pass right before generating external help
          Write-Host 'Final YAML normalization pass before external help generation...' -ForegroundColor Cyan
          Get-ChildItem -Path $env:DOCS_PATH -Filter *.md -File -ErrorAction SilentlyContinue | ForEach-Object {
            $path = $_.FullName
            try {
              $text = Get-Content -Raw -Encoding UTF8 -ErrorAction Stop $path
              $orig = $text
              
              # Fix inline YAML (```yaml Type: String[] on same line)
              $text = [regex]::Replace($text, '(?m)^```yaml[ \t]+(.+)$', { param($m) '```yaml' + [Environment]::NewLine + $m.Groups[1].Value })
              
              # Aggressively fix cramped YAML blocks (all replacement strings in vars so commas never break -replace)
              $nl = [Environment]::NewLine
              $replDefaultNone = 'Default value: None' + $nl + 'Accept pipeline input: False'
              $replInputFalse = 'Accept pipeline input: False' + $nl + 'Accept wildcard characters: False'
              $byPropByVal = 'ByPropertyName' + ',' + ' ByValue'
              $replInputTrue = 'Accept pipeline input: True (' + $byPropByVal + ')' + $nl + 'Accept wildcard characters: False'
              $replParamSets = 'Parameter Sets: '
              $replFirstGroup = '$1' + $nl + '$2'
              $replTypeParam = '$1'
              $replPositionDefault = "`$1" + $nl + 'Default value: None'
              $replCharacters = 'Accept wildcard characters: False'
              $replRequired = 'Required: $1'
              $replDefaultFalse = 'Default value: False' + $nl + 'Accept pipeline input: False'
              $replValueToDefault = 'Default value: $1' + $nl + 'Accept pipeline input: False'
              $replNewlineParamSets = "`$1" + $nl + 'Parameter Sets: '
              $pattern = '(?ms)```yaml\s*(.+?)\s*```'
              $yamlBlocks = [regex]::Matches($text, $pattern)
              if ($yamlBlocks.Count -gt 0) {
                $offset = 0
                foreach ($m in $yamlBlocks) {
                  $inner = $m.Groups[1].Value
                  $fixed = $inner -replace '(\S)\s+([A-Z][a-zA-Z0-9\s]*:)', $replFirstGroup
                  $fixed = $fixed -replace 'Parameter\r?\nSets: ', $replParamSets
                  $fixed = $fixed -replace '(?m)^Sets:\s*', $replParamSets
                  $fixed = $fixed -replace '(?m)^(Type:\s*.+?)Parameter\s*$', $replTypeParam
                  $fixed = $fixed -replace '([^\r\n])Parameter Sets:', $replNewlineParamSets
                  $fixed = $fixed -replace '(?m)^(Position:\s*[^\r\n]+?)Default\s*$', $replPositionDefault
                  $fixed = $fixed -replace 'value:NoneAcceptpipeline', $replDefaultNone
                  $fixed = $fixed -replace 'value: NoneAcceptpipeline', $replDefaultNone
                  $fixed = $fixed -replace 'value:FalseAcceptpipeline', $replDefaultFalse
                  $fixed = $fixed -replace 'value: FalseAcceptpipeline', $replDefaultFalse
                  $fixed = $fixed -replace '(?m)^value:\s*(.+?)Acceptpipeline\s*$', $replValueToDefault
                  $fixed = $fixed -replace '(?m)^value:\s*(.+)\s*$', 'Default value: $1'
                  $fixed = $fixed -replace 'input:FalseAcceptwildcard', $replInputFalse
                  $fixed = $fixed -replace 'input: True \([^)]+\)Acceptwildcard', $replInputTrue
                  $fixed = $fixed -replace '(?m)^characters:\s*False\s*$', $replCharacters
                  $fixed = $fixed -replace '(?m)^(Position:\s*Named)Default\s*$', $replPositionDefault
                  $fixed = $fixed -replace '(?m)^Required:(True|False)\s*$', $replRequired
                  $fixed = [regex]::Replace($fixed, '(?s)value: @\((.*?)\)Acceptpipeline', {
                    param($match)
                    $inner = $match.Groups[1].Value -replace '\r\n\s*', ' '
                    'Default value: @(' + $inner + ')' + $nl + 'Accept pipeline input: False'
                  })
                  $newBlock = '```yaml' + $nl + $fixed + $nl + '```'
                  $startIndex = $m.Index + $offset
                  $length = $m.Length
                  $text = $text.Substring(0, $startIndex) + $newBlock + $text.Substring($startIndex + $length)
                  $offset += ($newBlock.Length - $length)
                }
              }
              
              if ($text -ne $orig) {
                Set-Content -Path $path -Value $text -Encoding UTF8 -NoNewline
                Write-Host "  Fixed YAML in: $($_.Name)" -ForegroundColor Green
              }
            } catch {
              Write-Warning "  Could not process $($_.Name): $_"
            }
          }

          $helpPath = Join-Path $env:MODULE_PATH $env:DOCS_LOCALE
          if (-not (Test-Path $helpPath)) {
            New-Item -Path $helpPath -ItemType Directory -Force | Out-Null
          }

          Write-Host "Generating external help into '$helpPath'..." -ForegroundColor Green
          try {
            New-ExternalHelp -Path $env:DOCS_PATH -OutputPath $helpPath -Force -ErrorAction Stop
            Write-Host "âœ… External help generated successfully." -ForegroundColor Green
          } catch {
            Write-Warning "New-ExternalHelp encountered errors. This may be due to malformed YAML in markdown files."
            Write-Warning "Error details: $_"
            
            # Try processing files individually to identify problematic ones
            Write-Host "Attempting to generate help for individual files..." -ForegroundColor Yellow
            $mdFiles = Get-ChildItem -Path $env:DOCS_PATH -Filter *.md -File
            $goodFiles = @()
            foreach ($file in $mdFiles) {
              try {
                $testPath = Join-Path $env:TEMP 'help-validate'
                if (-not (Test-Path $testPath)) { New-Item -ItemType Directory -Path $testPath -Force | Out-Null }
                New-ExternalHelp -Path $file.FullName -OutputPath $testPath -Force -ErrorAction Stop | Out-Null
                $goodFiles += $file.FullName
              } catch {
                Write-Warning "Skipping problematic file: $($file.Name) - $_"
              }
            }
            Remove-Item (Join-Path $env:TEMP 'help-validate') -Recurse -Force -ErrorAction SilentlyContinue
            if ($goodFiles.Count -gt 0) {
              New-ExternalHelp -Path $goodFiles -OutputPath $helpPath -Force -ErrorAction Stop | Out-Null
              Write-Host "  Generated external help from $($goodFiles.Count) files" -ForegroundColor Green
            }

            if ($goodFiles.Count -eq 0) {
              throw "All markdown files failed to generate external help."
            }
          }

      - name: Commit Documentation Changes
        id: commit-docs
        if: env.COMMIT_ENABLED == 'true'
        shell: pwsh
        env:
          DOCS_PATH: ${{ env.DOCS_PATH }}
          MODULE_PATH: ${{ env.MODULE_PATH }}
          DOCS_LOCALE: ${{ env.DOCS_LOCALE }}
          COMMIT_MESSAGE: ${{ env.COMMIT_MESSAGE }}
          GIT_USER_NAME: ${{ env.GIT_USER_NAME != '' && env.GIT_USER_NAME || 'github-actions[bot]' }}
          GIT_USER_EMAIL: ${{ env.GIT_USER_EMAIL != '' && env.GIT_USER_EMAIL || 'github-actions[bot]@users.noreply.github.com' }}
        run: |
          $ErrorActionPreference = 'Stop'
          git add $env:DOCS_PATH
          git add (Join-Path $env:MODULE_PATH $env:DOCS_LOCALE)

          $staged = git diff --cached --name-only
          if ($staged) {
            git commit -m "$env:COMMIT_MESSAGE"
            if ($LASTEXITCODE -ne 0) { throw "git commit failed (exit code $LASTEXITCODE)" }
            git push
            if ($LASTEXITCODE -ne 0) { throw "git push failed (exit code $LASTEXITCODE)" }
            "docs_updated=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          } else {
            Write-Host "No documentation changes to commit." -ForegroundColor Yellow
            "docs_updated=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          }

      - name: Documentation Summary
        if: always()
        shell: pwsh
        env:
          DOCS_UPDATED: ${{ steps.commit-docs.outputs.docs_updated }}
        run: |
          $status = if ($env:DOCS_UPDATED -eq 'true') { 'updated' } elseif ($env:DOCS_UPDATED -eq 'false') { 'unchanged' } else { 'generated (not committed)' }
          Write-Host "Documentation generation complete: $status." -ForegroundColor Cyan

