name: Publish Documentation to Website

on:
  workflow_call:
    inputs:
      docs_path:
        description: 'Path to the documentation files'
        required: false
        type: string
        default: './docs'
      website_api_endpoint:
        description: 'API endpoint for documentation publishing'
        required: true
        type: string
      docs_format:
        description: 'Format of documentation files (markdown, html, json)'
        required: false
        type: string
        default: 'markdown'
      module_name:
        description: 'Name of the module (for organization on website)'
        required: false
        type: string
      docs_version:
        description: 'Version of the documentation'
        required: false
        type: string
      publish_method:
        description: 'Method to publish docs (api, git, ftp)'
        required: false
        type: string
        default: 'api'
      dry_run:
        description: 'Perform a dry run without actually publishing'
        required: false
        type: boolean
        default: false
    secrets:
      WEBSITE_API_KEY:
        description: 'API key for website documentation publishing'
        required: true
      WEBSITE_AUTH_TOKEN:
        description: 'Optional additional authentication token'
        required: false
    outputs:
      published:
        description: 'Whether documentation was successfully published'
        value: ${{ jobs.publish-docs.outputs.published }}
      docs_url:
        description: 'URL where documentation was published'
        value: ${{ jobs.publish-docs.outputs.docs_url }}

jobs:
  publish-docs:
    name: Publish Documentation to Website
    runs-on: ubuntu-latest
    outputs:
      published: ${{ steps.publish.outputs.published }}
      docs_url: ${{ steps.publish.outputs.docs_url }}
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4

    - name: Validate Documentation Path
      id: validate
      shell: bash
      run: |
        DOCS_PATH="${{ inputs.docs_path }}"
        
        echo "Checking documentation path: $DOCS_PATH"
        
        if [ ! -d "$DOCS_PATH" ]; then
          echo "âŒ Documentation path does not exist: $DOCS_PATH"
          exit 1
        fi
        
        # Count documentation files
        if [ "${{ inputs.docs_format }}" = "markdown" ]; then
          DOC_COUNT=$(find "$DOCS_PATH" -name "*.md" | wc -l)
          FILE_PATTERN="*.md"
        elif [ "${{ inputs.docs_format }}" = "html" ]; then
          DOC_COUNT=$(find "$DOCS_PATH" -name "*.html" | wc -l)
          FILE_PATTERN="*.html"
        elif [ "${{ inputs.docs_format }}" = "json" ]; then
          DOC_COUNT=$(find "$DOCS_PATH" -name "*.json" | wc -l)
          FILE_PATTERN="*.json"
        else
          DOC_COUNT=$(find "$DOCS_PATH" -type f | wc -l)
          FILE_PATTERN="*"
        fi
        
        echo "Found $DOC_COUNT documentation files ($FILE_PATTERN)"
        
        if [ $DOC_COUNT -eq 0 ]; then
          echo "âŒ No documentation files found in $DOCS_PATH"
          exit 1
        fi
        
        echo "âœ… Documentation validation passed"
        echo "doc_count=$DOC_COUNT" >> $GITHUB_OUTPUT

    - name: Prepare Documentation Package
      id: prepare
      shell: bash
      run: |
        echo "Preparing documentation package..."
        
        DOCS_PATH="${{ inputs.docs_path }}"
        PACKAGE_DIR="docs-package"
        
        # Create package directory
        mkdir -p "$PACKAGE_DIR"
        
        # Copy documentation files
        cp -r "$DOCS_PATH"/* "$PACKAGE_DIR/"
        
        # Create metadata file
        cat > "$PACKAGE_DIR/metadata.json" << EOF
        {
          "module_name": "${{ inputs.module_name }}",
          "docs_version": "${{ inputs.docs_version }}",
          "docs_format": "${{ inputs.docs_format }}",
          "publish_date": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
          "repository": "${{ github.repository }}",
          "commit_sha": "${{ github.sha }}",
          "workflow_run_id": "${{ github.run_id }}"
        }
        EOF
        
        # Create file inventory
        echo "Creating file inventory..."
        find "$PACKAGE_DIR" -type f -name "*.${{ inputs.docs_format }}" > "$PACKAGE_DIR/file_inventory.txt" || \
        find "$PACKAGE_DIR" -type f > "$PACKAGE_DIR/file_inventory.txt"
        
        echo "âœ… Documentation package prepared"
        echo "package_dir=$PACKAGE_DIR" >> $GITHUB_OUTPUT

    - name: Publish via API
      id: publish
      if: inputs.publish_method == 'api'
      shell: bash
      run: |
        set -eo pipefail
        echo "Publishing documentation via API..."

        API_ENDPOINT="${{ inputs.website_api_endpoint }}"
        API_KEY="${{ secrets.WEBSITE_API_KEY }}"
        AUTH_TOKEN="${{ secrets.WEBSITE_AUTH_TOKEN }}"
        PACKAGE_DIR="${{ steps.prepare.outputs.package_dir }}"
        DRY_RUN="${{ inputs.dry_run }}"

        if [ -z "$API_KEY" ]; then
          echo "âŒ WEBSITE_API_KEY secret is required"
          exit 1
        fi

        if [ -z "$API_ENDPOINT" ]; then
          echo "âŒ website_api_endpoint input is required"
          exit 1
        fi

        echo "Preparing API payload..."
        PAYLOAD=$(cat << EOF
        {
          "module_name": "${{ inputs.module_name }}",
          "docs_version": "${{ inputs.docs_version }}",
          "docs_format": "${{ inputs.docs_format }}",
          "repository": "${{ github.repository }}",
          "commit_sha": "${{ github.sha }}",
          "files": []
        }
        EOF
        )

        CURL_ARGS=(
          -s -w "\n%{http_code}"
          -X POST
          -H "Content-Type: application/json"
          -H "X-API-Key: $API_KEY"
        )

        if [ -n "$AUTH_TOKEN" ]; then
          CURL_ARGS+=( -H "Authorization: Bearer $AUTH_TOKEN" )
        fi

        if [ "$DRY_RUN" = "true" ]; then
          CURL_ARGS+=( -H "X-Dry-Run: true" )
          echo "ğŸ” Performing dry run - no actual publishing will occur"
        fi

        RESPONSE=$(curl "${CURL_ARGS[@]}" -d "$PAYLOAD" "$API_ENDPOINT" 2>&1)
        HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
        RESPONSE_BODY=$(echo "$RESPONSE" | sed '$d')

        echo "HTTP Status Code: $HTTP_CODE"
        if [ -n "$RESPONSE_BODY" ]; then
          echo "Response (truncated):" $(echo "$RESPONSE_BODY" | head -c 400)
        fi

        if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
          echo "âœ… Documentation published successfully"

          DOCS_URL=$(echo "$RESPONSE_BODY" | jq -r '.url // empty' 2>/dev/null || true)
          if [ -z "$DOCS_URL" ]; then
            DOCS_URL="${API_ENDPOINT%/api/*}/docs/${{ inputs.module_name }}"
          fi

          echo "published=true" >> $GITHUB_OUTPUT
          echo "docs_url=$DOCS_URL" >> $GITHUB_OUTPUT

          if [ "$DRY_RUN" = "true" ]; then
            echo "ğŸ” Dry run completed successfully"
          else
            echo "ğŸ“– Documentation available at: $DOCS_URL"
          fi
        else
          echo "âŒ API request failed with status $HTTP_CODE"
          echo "published=false" >> $GITHUB_OUTPUT
          exit 1
        fi

    - name: Publish via Git (Alternative Method)
      id: publish_git
      if: inputs.publish_method == 'git'
      shell: bash
      run: |
        echo "ğŸš§ Git publishing method not yet implemented"
        echo "This would typically:"
        echo "1. Clone a documentation repository"
        echo "2. Update documentation files"
        echo "3. Commit and push changes"
        echo "4. Trigger website rebuild"
        
        # Placeholder for git-based publishing
        echo "published=false" >> $GITHUB_OUTPUT
        echo "This publishing method is not yet implemented" >> $GITHUB_OUTPUT
          exit 1

    - name: Publish via FTP (Alternative Method)
      id: publish_ftp
      if: inputs.publish_method == 'ftp'
      shell: bash
      run: |
        echo "ğŸš§ FTP publishing method not yet implemented"
        echo "This would typically:"
        echo "1. Connect to FTP server"
        echo "2. Upload documentation files"
        echo "3. Update website index"
        
        # Placeholder for FTP-based publishing
        echo "published=false" >> $GITHUB_OUTPUT
        echo "This publishing method is not yet implemented" >> $GITHUB_OUTPUT
          exit 1

    - name: Cleanup
      if: always()
      shell: bash
      run: |
        # Clean up temporary files
        PACKAGE_DIR="${{ steps.prepare.outputs.package_dir }}"
        if [ -d "$PACKAGE_DIR" ]; then
          rm -rf "$PACKAGE_DIR"
          echo "âœ… Cleaned up temporary package directory"
        fi

    - name: Publication Summary
      if: always()
      shell: bash
      run: |
        echo "=== Documentation Publication Summary ===" 
        echo "ğŸ“„ Module: ${{ inputs.module_name }}"
        echo "ğŸ“„ Version: ${{ inputs.docs_version }}"
        echo "ğŸ“„ Format: ${{ inputs.docs_format }}"
        echo "ğŸ“„ Method: ${{ inputs.publish_method }}"
        echo "ğŸ“„ Files Found: ${{ steps.validate.outputs.doc_count }}"
        
        PUBLISHED="${{ steps.publish.outputs.published }}${{ steps.publish_git.outputs.published }}${{ steps.publish_ftp.outputs.published }}"
        DOCS_URL="${{ steps.publish.outputs.docs_url }}${{ steps.publish_git.outputs.docs_url }}${{ steps.publish_ftp.outputs.docs_url }}"
        
        if [ "$PUBLISHED" = "true" ]; then
          echo "âœ… Status: Published successfully"
          if [ -n "$DOCS_URL" ]; then
            echo "ğŸ”— URL: $DOCS_URL"
          fi
        else
          echo "âŒ Status: Publication failed or not attempted"
        fi